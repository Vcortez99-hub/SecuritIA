import nmap
import asyncio
import socket
import ssl
import requests
from typing import List, Dict, Any, Optional
import subprocess
import json
import logging
from datetime import datetime
import concurrent.futures
import re
from urllib.parse import urlparse
import whois
import dns.resolver

logger = logging.getLogger(__name__)

class VulnerabilityScanner:
    def __init__(self):
        self.nm = nmap.PortScanner()
        self.common_ports = "21,22,23,25,53,80,110,443,993,995,1723,3306,3389,5432,5900,8080,8443"
        
    async def scan(self, target: str, scan_type: str = "comprehensive") -> List[Dict[str, Any]]:
        """Executar scan de vulnerabilidades completo"""
        try:
            logger.info(f"Iniciando scan de vulnerabilidades para {target}")
            vulnerabilities = []
            
            # 1. Port Scanning
            open_ports = await self.port_scan(target)
            
            # 2. Service Detection
            services = await self.service_detection(target, open_ports)
            
            # 3. SSL/TLS Analysis
            if any(port in [443, 8443] for port in open_ports):
                ssl_vulns = await self.ssl_analysis(target)
                vulnerabilities.extend(ssl_vulns)
            
            # 4. Web Application Scanning
            if any(port in [80, 443, 8080, 8443] for port in open_ports):
                web_vulns = await self.web_app_scan(target)
                vulnerabilities.extend(web_vulns)
            
            # 5. Network Service Vulnerabilities
            network_vulns = await self.network_service_scan(target, services)
            vulnerabilities.extend(network_vulns)
            
            # 6. DNS Analysis
            dns_vulns = await self.dns_analysis(target)
            vulnerabilities.extend(dns_vulns)
            
            # 7. Information Gathering
            info_vulns = await self.information_gathering(target)
            vulnerabilities.extend(info_vulns)
            
            logger.info(f"Scan concluído: {len(vulnerabilities)} vulnerabilidades encontradas")
            return vulnerabilities
            
        except Exception as e:
            logger.error(f"Erro no scan de vulnerabilidades: {str(e)}")
            return []
    
    async def port_scan(self, target: str) -> List[int]:
        """Scan de portas básico"""
        try:
            logger.info(f"Iniciando port scan para {target}")
            
            def run_nmap():
                self.nm.scan(target, self.common_ports, arguments='-sV -sC --script vuln')
                return self.nm
            
            # Executar nmap em thread separada
            loop = asyncio.get_event_loop()
            with concurrent.futures.ThreadPoolExecutor() as executor:
                result = await loop.run_in_executor(executor, run_nmap)
            
            open_ports = []
            for host in result.all_hosts():
                for protocol in result[host].all_protocols():
                    ports = result[host][protocol].keys()
                    for port in ports:
                        state = result[host][protocol][port]['state']
                        if state == 'open':
                            open_ports.append(port)
            
            logger.info(f"Portas abertas encontradas: {open_ports}")
            return open_ports
            
        except Exception as e:
            logger.error(f"Erro no port scan: {str(e)}")
            return []
    
    async def service_detection(self, target: str, ports: List[int]) -> Dict[int, Dict[str, Any]]:
        """Detecção de serviços nas portas abertas"""
        services = {}
        
        try:
            for port in ports:
                service_info = await self.detect_service(target, port)
                if service_info:
                    services[port] = service_info
            
            return services
            
        except Exception as e:
            logger.error(f"Erro na detecção de serviços: {str(e)}")
            return {}
    
    async def detect_service(self, target: str, port: int) -> Optional[Dict[str, Any]]:
        """Detectar serviço específico em uma porta"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)
            
            result = sock.connect_ex((target, port))
            if result == 0:
                try:
                    # Tentar obter banner
                    sock.send(b'HEAD / HTTP/1.0\r\n\r\n')
                    banner = sock.recv(1024).decode('utf-8', errors='ignore')
                    
                    service_info = {
                        'port': port,
                        'state': 'open',
                        'banner': banner[:200] if banner else '',
                        'service': self.identify_service(port, banner)
                    }
                    
                    sock.close()
                    return service_info
                    
                except:
                    sock.close()
                    return {'port': port, 'state': 'open', 'service': 'unknown'}
            
            sock.close()
            return None
            
        except Exception as e:
            logger.error(f"Erro ao detectar serviço na porta {port}: {str(e)}")
            return None
    
    def identify_service(self, port: int, banner: str) -> str:
        """Identificar serviço baseado na porta e banner"""
        common_services = {
            21: 'ftp',
            22: 'ssh',
            23: 'telnet',
            25: 'smtp',
            53: 'dns',
            80: 'http',
            110: 'pop3',
            443: 'https',
            993: 'imaps',
            995: 'pop3s',
            3306: 'mysql',
            3389: 'rdp',
            5432: 'postgresql',
            8080: 'http-alt',
            8443: 'https-alt'
        }
        
        service = common_services.get(port, 'unknown')
        
        # Refinar baseado no banner
        if banner:
            banner_lower = banner.lower()
            if 'apache' in banner_lower:
                service += '/apache'
            elif 'nginx' in banner_lower:
                service += '/nginx'
            elif 'iis' in banner_lower:
                service += '/iis'
        
        return service
    
    async def ssl_analysis(self, target: str) -> List[Dict[str, Any]]:
        """Análise SSL/TLS"""
        vulnerabilities = []
        
        try:
            logger.info(f"Analisando SSL/TLS para {target}")
            
            # Testar diferentes portas SSL
            ssl_ports = [443, 8443]
            
            for port in ssl_ports:
                try:
                    context = ssl.create_default_context()
                    context.check_hostname = False
                    context.verify_mode = ssl.CERT_NONE
                    
                    with socket.create_connection((target, port), timeout=10) as sock:
                        with context.wrap_socket(sock, server_hostname=target) as ssock:
                            cert = ssock.getpeercert()
                            cipher = ssock.cipher()
                            version = ssock.version()
                            
                            # Verificar vulnerabilidades SSL/TLS
                            ssl_vulns = self.check_ssl_vulnerabilities(cert, cipher, version, port)
                            vulnerabilities.extend(ssl_vulns)
                            
                except Exception as e:
                    logger.debug(f"Erro SSL na porta {port}: {str(e)}")
                    continue
            
            return vulnerabilities
            
        except Exception as e:
            logger.error(f"Erro na análise SSL: {str(e)}")
            return []
    
    def check_ssl_vulnerabilities(self, cert: Dict, cipher: tuple, version: str, port: int) -> List[Dict[str, Any]]:
        """Verificar vulnerabilidades SSL específicas"""
        vulnerabilities = []
        
        try:
            # Verificar certificado expirado
            if cert and 'notAfter' in cert:
                exp_date = datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')
                if exp_date < datetime.now():
                    vulnerabilities.append({
                        'name': 'Certificado SSL Expirado',
                        'severity': 'HIGH',
                        'cvss_score': 7.5,
                        'port': port,
                        'description': f'Certificado SSL expirou em {exp_date}',
                        'recommendation': 'Renovar o certificado SSL imediatamente'
                    })
            
            # Verificar versão SSL/TLS insegura
            if version in ['SSLv2', 'SSLv3', 'TLSv1', 'TLSv1.1']:
                vulnerabilities.append({
                    'name': 'Versão SSL/TLS Insegura',
                    'severity': 'MEDIUM',
                    'cvss_score': 5.3,
                    'port': port,
                    'description': f'Usando versão insegura: {version}',
                    'recommendation': 'Atualizar para TLS 1.2 ou superior'
                })
            
            # Verificar cipher suites fracos
            if cipher and len(cipher) >= 2:
                cipher_name = cipher[0]
                if any(weak in cipher_name.upper() for weak in ['RC4', 'DES', 'MD5', 'NULL']):
                    vulnerabilities.append({
                        'name': 'Cipher Suite Fraco',
                        'severity': 'MEDIUM',
                        'cvss_score': 4.3,
                        'port': port,
                        'description': f'Cipher suite fraco detectado: {cipher_name}',
                        'recommendation': 'Desabilitar cipher suites fracos'
                    })
            
            return vulnerabilities
            
        except Exception as e:
            logger.error(f"Erro ao verificar vulnerabilidades SSL: {str(e)}")
            return []
    
    async def web_app_scan(self, target: str) -> List[Dict[str, Any]]:
        """Scan de aplicação web"""
        vulnerabilities = []
        
        try:
            logger.info(f"Iniciando scan de aplicação web para {target}")
            
            # URLs para testar
            urls = [f"http://{target}", f"https://{target}"]
            
            for url in urls:
                try:
                    # Teste básico de conectividade
                    response = requests.get(url, timeout=10, verify=False)
                    
                    # Verificar headers de segurança
                    security_vulns = self.check_security_headers(response, url)
                    vulnerabilities.extend(security_vulns)
                    
                    # Verificar tecnologias expostas
                    tech_vulns = self.check_exposed_technologies(response, url)
                    vulnerabilities.extend(tech_vulns)
                    
                    # Teste de injeção SQL básico
                    sql_vulns = await self.basic_sql_injection_test(url)
                    vulnerabilities.extend(sql_vulns)
                    
                    # Teste XSS básico
                    xss_vulns = await self.basic_xss_test(url)
                    vulnerabilities.extend(xss_vulns)
                    
                except requests.exceptions.RequestException:
                    continue
            
            return vulnerabilities
            
        except Exception as e:
            logger.error(f"Erro no scan de aplicação web: {str(e)}")
            return []
    
    def check_security_headers(self, response: requests.Response, url: str) -> List[Dict[str, Any]]:
        """Verificar headers de segurança"""
        vulnerabilities = []
        headers = response.headers
        
        security_headers = {
            'X-Frame-Options': 'Clickjacking protection missing',
            'X-Content-Type-Options': 'MIME type sniffing protection missing',
            'X-XSS-Protection': 'XSS protection header missing',
            'Strict-Transport-Security': 'HSTS header missing',
            'Content-Security-Policy': 'CSP header missing'
        }
        
        for header, description in security_headers.items():
            if header not in headers:
                vulnerabilities.append({
                    'name': f'Missing Security Header: {header}',
                    'severity': 'LOW',
                    'cvss_score': 3.1,
                    'port': 80 if url.startswith('http://') else 443,
                    'description': description,
                    'recommendation': f'Implementar header {header}'
                })
        
        return vulnerabilities
    
    def check_exposed_technologies(self, response: requests.Response, url: str) -> List[Dict[str, Any]]:
        """Verificar tecnologias expostas"""
        vulnerabilities = []
        headers = response.headers
        
        # Verificar server header
        if 'Server' in headers:
            server = headers['Server']
            vulnerabilities.append({
                'name': 'Server Information Disclosure',
                'severity': 'INFO',
                'cvss_score': 0.0,
                'port': 80 if url.startswith('http://') else 443,
                'description': f'Server header expõe informações: {server}',
                'recommendation': 'Remover ou ofuscar header Server'
            })
        
        # Verificar X-Powered-By
        if 'X-Powered-By' in headers:
            powered_by = headers['X-Powered-By']
            vulnerabilities.append({
                'name': 'Technology Stack Disclosure',
                'severity': 'INFO',
                'cvss_score': 0.0,
                'port': 80 if url.startswith('http://') else 443,
                'description': f'X-Powered-By header expõe tecnologia: {powered_by}',
                'recommendation': 'Remover header X-Powered-By'
            })
        
        return vulnerabilities
    
    async def basic_sql_injection_test(self, url: str) -> List[Dict[str, Any]]:
        """Teste básico de injeção SQL"""
        vulnerabilities = []
        
        try:
            # Payloads básicos para teste
            sql_payloads = ["'", "' OR '1'='1", "'; DROP TABLE users; --"]
            
            for payload in sql_payloads:
                test_url = f"{url}?id={payload}"
                try:
                    response = requests.get(test_url, timeout=5, verify=False)
                    
                    # Verificar indicadores de erro SQL
                    error_indicators = [
                        'mysql_fetch_array',
                        'ORA-01756',
                        'Microsoft OLE DB Provider',
                        'PostgreSQL query failed',
                        'Warning: mysql_',
                        'valid MySQL result',
                        'MySqlClient.'
                    ]
                    
                    for indicator in error_indicators:
                        if indicator.lower() in response.text.lower():
                            vulnerabilities.append({
                                'name': 'Potential SQL Injection',
                                'severity': 'HIGH',
                                'cvss_score': 9.8,
                                'port': 80 if url.startswith('http://') else 443,
                                'description': f'Possível injeção SQL detectada com payload: {payload}',
                                'recommendation': 'Implementar prepared statements e validação de entrada'
                            })
                            break
                            
                except requests.exceptions.RequestException:
                    continue
        
        except Exception as e:
            logger.error(f"Erro no teste de SQL injection: {str(e)}")
        
        return vulnerabilities
    
    async def basic_xss_test(self, url: str) -> List[Dict[str, Any]]:
        """Teste básico de XSS"""
        vulnerabilities = []
        
        try:
            xss_payload = "<script>alert('XSS')</script>"
            test_url = f"{url}?q={xss_payload}"
            
            response = requests.get(test_url, timeout=5, verify=False)
            
            if xss_payload in response.text:
                vulnerabilities.append({
                    'name': 'Reflected Cross-Site Scripting (XSS)',
                    'severity': 'MEDIUM',
                    'cvss_score': 6.1,
                    'port': 80 if url.startswith('http://') else 443,
                    'description': 'XSS refletido detectado - entrada não filtrada',
                    'recommendation': 'Implementar sanitização de entrada e encoding de saída'
                })
        
        except Exception as e:
            logger.error(f"Erro no teste de XSS: {str(e)}")
        
        return vulnerabilities
    
    async def network_service_scan(self, target: str, services: Dict[int, Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Scan de vulnerabilidades em serviços de rede"""
        vulnerabilities = []
        
        try:
            for port, service_info in services.items():
                service = service_info.get('service', '')
                
                # SSH vulnerabilities
                if 'ssh' in service.lower():
                    ssh_vulns = await self.check_ssh_vulnerabilities(target, port)
                    vulnerabilities.extend(ssh_vulns)
                
                # FTP vulnerabilities
                elif 'ftp' in service.lower():
                    ftp_vulns = await self.check_ftp_vulnerabilities(target, port)
                    vulnerabilities.extend(ftp_vulns)
                
                # Database vulnerabilities
                elif any(db in service.lower() for db in ['mysql', 'postgresql', 'mssql']):
                    db_vulns = await self.check_database_vulnerabilities(target, port, service)
                    vulnerabilities.extend(db_vulns)
        
        except Exception as e:
            logger.error(f"Erro no scan de serviços de rede: {str(e)}")
        
        return vulnerabilities
    
    async def check_ssh_vulnerabilities(self, target: str, port: int) -> List[Dict[str, Any]]:
        """Verificar vulnerabilidades SSH"""
        vulnerabilities = []
        
        try:
            # Teste de autenticação anônima
            import paramiko
            
            ssh = paramiko.SSHClient()
            ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            
            try:
                ssh.connect(target, port=port, username='anonymous', password='', timeout=5)
                vulnerabilities.append({
                    'name': 'SSH Anonymous Access',
                    'severity': 'HIGH',
                    'cvss_score': 9.8,
                    'port': port,
                    'description': 'Acesso SSH anônimo permitido',
                    'recommendation': 'Desabilitar acesso anônimo e configurar autenticação adequada'
                })
                ssh.close()
            except:
                pass
        
        except Exception as e:
            logger.debug(f"Erro no teste SSH: {str(e)}")
        
        return vulnerabilities
    
    async def check_ftp_vulnerabilities(self, target: str, port: int) -> List[Dict[str, Any]]:
        """Verificar vulnerabilidades FTP"""
        vulnerabilities = []
        
        try:
            import ftplib
            
            ftp = ftplib.FTP()
            try:
                ftp.connect(target, port, timeout=5)
                # Teste de login anônimo
                ftp.login('anonymous', 'anonymous@test.com')
                
                vulnerabilities.append({
                    'name': 'FTP Anonymous Access',
                    'severity': 'MEDIUM',
                    'cvss_score': 5.3,
                    'port': port,
                    'description': 'Login FTP anônimo permitido',
                    'recommendation': 'Desabilitar acesso FTP anônimo'
                })
                ftp.quit()
            except:
                pass
        
        except Exception as e:
            logger.debug(f"Erro no teste FTP: {str(e)}")
        
        return vulnerabilities
    
    async def check_database_vulnerabilities(self, target: str, port: int, service: str) -> List[Dict[str, Any]]:
        """Verificar vulnerabilidades de banco de dados"""
        vulnerabilities = []
        
        # Verificar se banco está exposto na internet
        vulnerabilities.append({
            'name': 'Database Service Exposed',
            'severity': 'HIGH',
            'cvss_score': 7.5,
            'port': port,
            'description': f'Serviço de banco de dados {service} exposto na internet',
            'recommendation': 'Restringir acesso ao banco de dados apenas para IPs necessários'
        })
        
        return vulnerabilities
    
    async def dns_analysis(self, target: str) -> List[Dict[str, Any]]:
        """Análise DNS"""
        vulnerabilities = []
        
        try:
            # DNS Zone Transfer test
            try:
                answers = dns.resolver.resolve(target, 'NS')
                for ns in answers:
                    ns_server = str(ns)
                    # Tentar zone transfer
                    try:
                        zone = dns.zone.from_xfr(dns.query.xfr(ns_server, target))
                        vulnerabilities.append({
                            'name': 'DNS Zone Transfer Enabled',
                            'severity': 'MEDIUM',
                            'cvss_score': 5.3,
                            'port': 53,
                            'description': f'Zone transfer permitido no servidor {ns_server}',
                            'recommendation': 'Restringir zone transfers apenas para servidores autorizados'
                        })
                    except:
                        pass
            except:
                pass
        
        except Exception as e:
            logger.error(f"Erro na análise DNS: {str(e)}")
        
        return vulnerabilities
    
    async def information_gathering(self, target: str) -> List[Dict[str, Any]]:
        """Coleta de informações"""
        vulnerabilities = []
        
        try:
            # WHOIS lookup
            try:
                domain_info = whois.whois(target)
                if domain_info and hasattr(domain_info, 'creation_date'):
                    vulnerabilities.append({
                        'name': 'Domain Information Disclosure',
                        'severity': 'INFO',
                        'cvss_score': 0.0,
                        'port': 0,
                        'description': f'Informações WHOIS disponíveis para {target}',
                        'recommendation': 'Considerar usar proteção de privacidade WHOIS'
                    })
            except:
                pass
        
        except Exception as e:
            logger.error(f"Erro na coleta de informações: {str(e)}")
        
        return vulnerabilities